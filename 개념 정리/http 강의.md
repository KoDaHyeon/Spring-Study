### IP(인터넷 프로토콜)

- 지정한 IP 주소에 데이터를 전달
- 패킷(Packet)이라는 통신 단위로 데이터를 전달



- 클라이언트 패킷 전달 : 출발지(출발 클라이언트)와 목적지(목표 서버)의 IP 주소와 전송데이터가 적힌 패킷을 인터넷 망에 던지면 인터넷 망의 노드끼리 패킷을 던지다보면 결국 목적지에 도착함

- 서버 패킷 전달 : 출발지(출발 서버)와 목적지(목표 클라이언트)의 IP 주소와 응답이 적힌 패킷을 인터넷 망에 던지면 인터넷 망의 노드끼리 패킷을 던지다보면 결국 목적지에 도착함
- 한계 
  1. 패킷을 받을 대상(목적지)이 없거나 서비스 불능 상태여도 패킷을 전송함(상대가 불능상태인지 모름...)
  2. 중간에 패킷이 사라지면..?(인터넷망 중간에 문제가 생기면), 패킷이 순서대로 안오면...?(메시지 용량이 크면 여러 패킷으로 잘라서 보냄- Hello | World 이렇게 보냈는데 World가 먼저 도착하면 World Hello가 됨) 이 해결이 안됨
  3. 같은 IP의 클라이언트에서 통신하는 애플리케이션이 여러 개(음악앱, 문서앱 동시사용중)면 어떻게 구분하지?

이 한계를 TCP, UDP가 해결해줌



### 웹브라우저 요청 흐름

1. 애플리케이션이 HTTP 메시지 생성

   - HTTP 요청 메시지(전송 데이터) : `GET /searth?q=hello&hl=ko HTTP/1.1 Host:www.google.com`

2. SOCKET 라이브러리를 통해 전달

3. 그 위에 TCP 정보를 덧씌움

   - 출발지 PORT, 목적지 PORT, **전송제어, 순서, 검증 정보**...
   - 이것들 덕분에 IP의 한계 해결

4. 그 위에 IP 정보를 덧씌움

   - 출발지 IP, 목적지 IP, ...

5. 그 위에 Ethernet frame을 덧씌워서 LAN 카드를 통해 서버로 전송됨

6. 서버가 요청 패킷을 받고 TCP, IP패킷 다 까서 HTTP 메시지를 꺼냄

7. 서버에서 HTTP 응답 메시지를 만들어내고 TCP, IP 씌우고 패킷 전송

   ```html
   HTTP/1.1 200 OK
   Content-Type: text/html;charset=UTF-8
   Content-Length: 3423
   
   <!-- HTML 데이터 -->
   <html>
     <body>...</body>
   </html> 
   ```

8. 클라이언트가 패킷을 받아 TCP, IP패킷 다 까서 HTTP 응답 메시지를 꺼냄 -> 웹브라우저에서 HTML 렌더링 -> HTML 화면을 볼 수 있음

### TCP

- 연결지향 - TPC 3 way handshake

  - 상대랑 나랑 **연결을 하고**, 메시지를 보냄
  - 1. 클라이언트가 서버에게 SYN(접속요청) 보냄
    2. 서버가 클라이언트에게 SYN(접속요청)+ACK(요청수락) 보냄
    3. 클라이언트가 서버에게 ACK(요청수락) 보냄
       - 이때 데이터 전송 가능
       - 연결이란, 그냥 두 통신상대가 연결가능하다고 서로 사인 보내는 느낌인듯.. 그 사이에 노드들은 연결됐는지 모르지만 사인 주고받기가 가능한 걸 보니 연결이 됐나보다.. 하고 여기는 것

- 데이터 전달 보증

  - 패킷이 중간에 누락되면 알 수 있음

  - 1. 클라이언트가 서버에게 데이터 전송
    2. 서버가 클라이언트에게 데이터 잘 받았다고 알려줌

    -> 응답이 안온다면 중간에 오류가 생겼다는 걸 알 수 있음

- 순서 보장

  - 1. 클라이언트가 서버에게 패킷1, 2, 3 순서로 전송
    2. 서버에 패킷 1, 3, 2 순서로 도착
    3. 서버가 클라이언트에게 패킷 2부터 다시 보내라고 요청



### UDP

- TCP 3 way handshake x
- 데이터 전달 보증 x
- 순서 보장 x
- TCP보다 단순하고 빠름
- IP와의 차이
  - PORT 제공(같은 IP의 클라이언트에서 통신하는 애플리케이션 구분 가능)
  - 체크섬(메시지가 제대로 왔는지 검증해주는 데이터)
- TCP는 건들 수가 없으니 UDP를 건들어서 좀더 최적화하기 위해 주로 사용



### PORT

같은 IP의 클라이언트에서 통신하는 애플리케이션이 여러 개면 어떻게 구분하지?

클라이언트의 IP로 패킷들이 날라왔을 때, 이게 게임앱에서 필요한 패킷인지, 음악앱에서 필요한 패킷인지 어떻게 구분하지?

-> TCP 패킷 정보를 통해 구분!

-> IP는 목적지 서버를 찾는 것(아파트 동수), PORT는 서버 안에서 돌아가는 애플리케이션을 찾는 것(아파트 내 호수)



### DNS

- IP는 복잡해서 기억하기 어려움
- IP는 변경될 수 있음

이런 문제점을 해결하기 위해 Domain Name System(DNS) 사용!

DNS 서버에 도메인 명(google.com), IP(200.200.200.2)를 매칭해서 등록해둠(도메인은 사야 함)(마치 전화번호부)

1. 클라이언트가 DNS 서버에게 도메인명(google.com) 의 IP 주소를 요청
2. DNS 서버가 클라이언트에게 IP 주소 응답(200.200.200.2)을 보냄
3. 클라이언트는 이 IP 주소로 접속



### URI, URL, URN

- URI(Resource Identifier - 리소스 식별) 개념 안에 URL(Resource Locator - 리소스 위치), URN(Resource Name - 리소스 이름)이 포함되어 있음

- Resource : 자원 : URI로 식별할 수 있는 모든 것
- URN은 리소스의 이름인데, 이름만으로 실제 리소스를 찾을 수 있는 방법은 별로 없음
- 따라서 URI와 URL을 거의 같은 개념으로 생각해도 됨

#### URL 구조

- `scheme://[userinfo@]host[:port][/path][?query][#fragment]`

- `https://www.google.com:443/search?q=hello&hl=ko`

| 구조명   | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| scheme   | - 프로토콜(어떤 방식으로 자원에 접근할 것인가의 규칙)<br />- http, https, ftp...<br />- 포트 생략 가능<br />- https는 http에 보안을 추가한 것(HTTP Secure) |
| userinfo | 거의 안씀                                                    |
| host     | 도메인명/IP주소                                              |
| port     | 일반적으로 생략                                              |
| path     | - 리소스 경로<br />- 계층적 구조(디렉토리처럼 - /items/iphone12) |
| query    | - key=value 형태<br />- ?로 시작<br />- &로 추가<br />- query parameter, query string으로 부름 |
| fragment | 잘 안씀                                                      |



### HTTP

- 거의 모든 형태의 데이터는 HTTP를 사용해서 전송

#### 클라이언트 서버 구조

- 1. 클라이언트가 서버에 요청을 보내고 응답을 대기
  2. 서버가 결과를 만들어서 응답
- 이렇게 클라이언트, 서버를 분리하는 것이 핵심!
- 비즈니스 로직, 데이터는 서버에 넣어놓고, 클라이언트는 UI에 집중

#### 무상태(stateless) 프로토콜

- **stateful(상태 유지)**

  - 중간에 다른 서버로 바뀌면 안됨(항상 같은 서버 유지)
    - 중간에 서버 장애가 난다면? 처음부터 다시 해야 함
  - 최소한으로만 사용해야 함

  ---

  <점원이 계속 같다면>

  1. 고객 : 이 노트북 얼마인가요?

     점원 : 100만원 입니다. **(노트북 상태 유지)**

  2. 고객 : 2개 구매할게요.

     점원 : 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요? **(노트북, 2개 상태 유지)**

  3. 고객 : 신용카드로 할게요.

     점원 : 200만원 결제 완료되었습니다. **(노트북, 2개, 신용카드 상태 유지)**

  <점원이 중간에 바뀌면>

  1. 고객 : 이 노트북 얼마인가요?

     점원A : 100만원 입니다.

  2. 고객 : 2개 구매할게요.

     점원B : ?무엇을 2개 구매하시겠어요?

  3. 고객 : 신용카드로 할게요.

     점원C : ?무슨 제품을 몇 개 신용카드로 구매하시겠어요?



- **stateless(무상태)**

  - 상대가 필요한 데이터를 그때그때 다! 넘겨줌

  - 중간에 다른 서버로 바뀌어도 됨
    - 중간에 서버 장애가 난다면? 다른 서버에게 전달하면 됨
  - 갑자기 클라이언트 요청이 증가해도 서버 대거 투입 가능
  - -> 응답 서버를 쉽게 바꿀 수 있다 => 무한한 서버 증설 가능
  - 한계 : 무상태로 설계할 수 없는 경우도 있음
    - ex) 상태 유지해야하는 '로그인 서버'
  - 최대한 stateless로 설계해야 함!!!!!

  ---

  <점원이 계속 같다면>

  1. 고객 : 이 노트북 얼마인가요?

     점원 : 100만원 입니다. 

  2. 고객 : 노트북 2개 구매할게요.

     점원 : 노트북 2개는 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?

  3. 고객 : 노트북 2개를 신용카드로 구매할게요.

     점원 : 200만원 결제 완료되었습니다.

  <점원이 중간에 바뀌면>

  1. 고객 : 이 노트북 얼마인가요?

     점원A : 100만원 입니다. 

  2. 고객 : 노트북 2개 구매할게요.

     점원B : 노트북 2개는 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?

  3. 고객 : 노트북 2개를 신용카드로 구매할게요.

     점원C : 200만원 결제 완료되었습니다.



### 비연결성

- 연결을 유지하는 모델
  - 클라이언트와 서버가 요청, 응답을 한 후에도 연결을 유지하므로 서버 자원을 소모하고 있음
- 연결을 유지하지 않는 모델
  - 클라이언트와 서버가 요청, 응답을 한 후 연결 끊으므로 서버 자원을 최소한으로만 소모
  - 단점
    - 요청, 응답할 때마다 TCP/IP 연결을 새로 맺어야 하므로 3 way handshake 시간이 소요됨
    - HTML 뿐만 아니라 수많은 이미지, css, js 등 자원이 다운로드 되는데, 각 자원 다운로드 할 때마다 연결 맺고 끊으면 낭비
    - 해결 : HTTP 지속 연결(얼마동안 유지하자!)

> HTTP는 기본적으로 연결을 유지하지 않는 모델!
>
> 따라서 많은 인원이 서버를 사용해도 서버 자원을 효율적으로 사용



### HTTP 메시지

#### 요청 메시지

```
GET /searth?q=hello&hl=ko
HTTP/1.1 Host:www.google.com
```



#### 응답 메시지

``` html
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<!-- HTML 데이터 -->
<html>
  <body>...</body>
</html> 
```

 - 상태 코드 - 클라이언트가 보낸 요청 성공/실패 여부
   - 200 : 성공
   - 400 : 클라이언트 요청 오류(클라이언트가 뭔가 잘못 보냄)
   - 500 : 서버 내부 오류



###  HTTP API

#### API URI 설계

URI는 리소스만 식별하는 것이 포인트

회원 목록 조회, 회원 조회, 회원 등록 에서 리소스는 회원 / 조회, 등록은 행위(메서드)

리소스는 명사, 행위는 동사

리소스는 URI로, 행위는 메서드로 표현! 

하지만 리소스만으로 URI를 설계할 수 없는 경우가 가끔 있다.. 이때는 컨트롤 URI 사용

POST /orders/{orderId}/**start-delivery**



### HTTP 메서드

POST, PUT, PATCH: 메시지 바디를 통해 데이터 전송

GET: 쿼리 파라미터로 데이터 전달

#### GET

: 리소스 조회(리소스 조회해야 하니 리소스 줘라)

- 서버에 전달하고 싶은 데이터는 query를 통해 전달

```java
//클라이언트의 요청 메시지(/members/100을 줘라!)
GET /members/100 HTTP/1.1
Host: localhost:8080
    
//서버의 응답 메시지
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 34
    
{
  "username"; "young",
  "age": 20
}
```



#### POST 

: 메시지 바디를 통해 데이터를 주고, 처리 부탁

- 리소스 URI에 POST 요청이 오면 어떻게 처리할지 리소스마다 정해야 함
  1. 데이터 등록
  2. 요청 데이터 처리
     - 프로세스를 처리하는 경우(프로세스 상태 변경)
  3. 다른 메서드로 처리하기 애매한 경우
     - 애매하면 POST 사용
     - JSON으로 데이터 넘겨서 조회하고 싶은데, GET은 메시지 바디를 전달하는 걸 지원하지 않는 경우가 있음. 이때는 POST를 사용해서 리소스 조회
       - 이런 어쩔 수 없는 경우 제외하고는 데이터 조회할 때는 GET 사용하기

```java
//클라이언트의 요청 메시지(/members에 전달)
POST /members HTTP/1.1
Content-Type: application/json
 
{
  "username"; "young",
  "age": 20
}

//서버의 응답 메시지
//Location: 자원이 생성된 path(서버가 결정)
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 34
Location: /members/100
    
{
  "username"; "young",
  "age": 20
}
```



#### PUT

: 데이터를 줄테니 리소스를 완전히 대체해주고(덮어쓰기), 없으면 생성해줘라

```java
//클라이언트의 요청 메시지
//POST와의 차이 : 클라이언트가 리소스의 위치를 알고 있어서 URI를 직접 지정(/members/100)
POST /members/100 HTTP/1.1
Content-Type: application/json
 
{
  "username"; "young",
  "age": 20
}
```

- 주의! 리소스가 있는 경우 리소스를 '완전히 대체'

  ```java
  //이걸로 대체하겠다
  {
    "age": 50
  }
  
  //해당 위치의 현재 데이터
  {
    "username"; "young",
    "age": 20
  }
  
  //대체된 데이터 : "username" 필드가 삭제됨!
  {
    "age": 50
  }
  ```

  

#### PATCH 

: 리소스를 부분적으로 변경해줘라

- PUT과 달리 특정 필드만 바꿀 수 있음
  - ex) 회원의 나이만 바꾸기



#### DELETE 

: 리소스 삭제

```java
//클라이언트의 요청 메시지
DELETE /members/100 HTTP/1.1
Host: localhost:8080
```



### HTTP 메소드 속성

1. 안전

   : 호출해도 리소스를 변경하지 않는다

   - GET은 안전, POST, PUT, DELETE는 안전x

2. 멱등

   : 똑같은 요청에 대해 한 번 호출하든 백 번 호출하든 결과가 똑같다

   - GET, PUT, DELETE는 멱등, POST는 멱등x
   - 자동복구 할 때 활용 : 서버가 정상 응답을 못했을 때, 클라이언트가 같은 요청을 다시 해도 되는가?의 판단 근거
   - 하지만 외부 요인으로 중간에 리소스가 변경되는 것은 고려하지 않는다
     - 사용자 1이 재요청하기 전에 다른 사용자가 PUT으로 리소스를 변경해버리는 경우

3. 캐시 가능

   : 웹브라우저가 로컬 PC 내부에 리소스(ex) 이미지)를 저장해둘 수 있다

   - 저장해두면 다음 번에 요청 안해도 됨

   - GET, HEAD



### 클라이언트에서 서버로 데이터 전달

#### 방식

1. 쿼리 파라미터(?key=value) 이용
   - GET,  검색어 입력, 게시판에 정렬 조건 입력 할 때 주로 사용
2. 메시지 바디 이용
   - POST, PUT, PATCH, 회원 가입, 상품 주문, 리소스 등록, 리소스 변경에 주로 사용

#### 상황

1. 정적 데이터 조회

   - 이미지, 정적 텍스트 문서
   - 쿼리 파라미터 없이 리소스 경로로 조회 가능
   - GET

2. 동적 데이터 조회

   - 검색, 게시판에 정렬 필터 입력 등에 사용

   - 쿼리 파라미터 사용
   - GET

3. HTML Form 태그

   - POST, GET만 가능
   - 회원 가입, 상품 주문, 데이터 변경 등에 사용
   - **컨트롤 URI**
     
     - 동사로 된 리소스 경로 사용(/members/{id}/delete)
   - form의 내용을 메시지 바디를 통해서 전송(key=value- 쿼리파라미터 형식)

   - ```html
     <form action="/save" method="post">
       <input type="text" name="username" />
       <input type="text" name="age" />
       <button type="submit">전송</button>
     </form>
     ```

     - 웹브라우저가 이 태그를 읽고 HTTP 메시지를 생성해줌

       ```java
       POST /save HTTP/1.1
       Host: localhost:8080
       Content-Type: application/x-www-form-urlencoded
       
       username=kim&age=20
       ```

4. HTTP API 데이터 전송

   - 서버 to 서버(백엔드끼리 통신), 앱 클라이언트, 웹클라이언트(React, VueJS...)와의 통신에서 사용
   - 회원 가입, 상품 주문, 데이터 변경 등에 사용

   - POST, PUT, PATCH, GET

   - ```java
     POST /members HTTP/1.1
     Content-Type: application/json
         
     {
       "username": "young",
       "age": 20
     }
     ```



### HTTP API 설계 예시

- 회원 목록 :  /members -> GET
- 회원 등록
  - POST 기반 등록 :  /members -> POST
    - 클라이언트는 등록될 리소스의 URI를 모름(서버가 리소스 등록 후 리소스 URI를 클라이언트에게 응답 메시지를 통해 알려줌)
    - **컬렉션** : 서버가 리소스의 URI를 생성하고 관리하는 디렉토리(/members)
    - 대부분 POST 기반 등록을 사용
  - PUT 기반 등록 :  /files/{filename} -> PUT
    - 클라이언트가 리소스 URI를 알고 있어야 함
    - **스토어** : 클라이언트가 리소스의 URI를 알고 관리(/files)
- 회원 조회 :  /members/{id} -> GET
- 회원 수정 :  /members/{id} -> PATCH, PUT, POST
  - PATCH가 제일 적합한 경우가 많음
  - PATCH, PUT 둘다 애매할 땐 POST 사용
- 회원 삭제 :  /members/{id} -> DELETE



### HTTP 상태 코드

: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

- 자세한 상태코드의 뜻을 몰라도 그냥 맨 앞자리(백의 자리)만 보고 해석해도 됨

  - 2xx : 요청 정상 처리 
- 주로 200, 201 정도만 사용
    
- 200 OK : 요청 성공
    - 201 Created : 요청 성공해서 새로운 리소스가 생성됨(POST 등 등록시에)
      - 응답 메시지에 Location 헤더(생성된 리소스의 URI가 적혀있음)가 있음
    - 202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음
      - ex) 접수는 되었지만 이따가 배치로 처리함
    - 204 No Content : 서버가 요청을 성공적으로 수행했지만, 응답 메시지에 보낼 데이터가 없음
      - ex) save 버튼의 결과로 아무 내용을 받지 않아도 된다
    
- 3xx : 요청을 완료하려면 추가 행동 필요
  
  - **리다이렉트** : 웹브라우저는 3xx 응답 결과에 Location 헤더가 았으면, Location 위치로 자동 이동
  
    - 1. 클라이언트가 /event 에 요청 메시지를 보냄. 
        2. 그런데 그 URI는 더이상 사용 안하고 /new-event라는 URI를 사용하고 있음. 서버가 요청을 받고 상태코드 301과 함께 `Location: /new-event`를 보냄. 
        3. 클라이언트의 웹브라우저가 자동으로 리다이렉트 해서 URL을 /new-event로 바꾼 후, /new-event로 다시 요청 메시지를 보냄. 
        4. 서버에서 상태코드 200 OK의 응답 메시지를 보냄.
  
    - 리다이렉션 종류
  
      1. **영구 리다이렉션** : 리소스의 URI가 영구적으로 이동(이전 URI는 더이상 사용x)
  
         - 301 Moved Permanently
             - 리다이렉트 시 요청 메소드가 GET으로 변하고, 메시지 바디가 제거될 수 있음 -> 웹브라우저는 새로운 페이지의 화면을 띄우게 됨
             - <img width="479" alt="301" src="https://user-images.githubusercontent.com/43772750/141615018-8068865c-f5d7-4627-9375-51ae366e7731.PNG">
           - 308
  
      2. **일시 리다이렉션** : 리소스의 URI가 일시적으로 변경
  
         - ex) 주문 완료 후 주문 내역 화면으로 이동
  
         - 302 Found : 리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거될 수 있음(대부분 GET으로 변함)
  
           - 307/303이 좀더 명확하지만, 많은 라이브러리들이 302를 사용하기 때문에 302 사용해도 상관없음
  
         - 307 Temporary Redirect : 리다이렉트 시 요청 메소드(GET으로 바꾸지x)와 본문 유지
  
         - 303 See Other : 리다이렉트 시 요청 메소드가 무조건 GET으로 변경
  
         - PRG : Post/redirect/Get
  
           - <img width="472" alt="PRG" src="https://user-images.githubusercontent.com/43772750/141615352-73294046-fa8e-4ec9-bfa3-09f7ed5df712.PNG">
  
           - POST로 주문 후에 웹브라우저를 새로고침(=바로 이전 요청을 다시 수행) 하면? POST 요청이 한번 더 돼서 중복 주문이 될 수도 있다!
             - 이를 막기 위해 POST로 주문 후에 응답 메시지를 302로 줘서 주문 결과 화면을 GET으로 리다이렉트하도록 함
             - 그러면 새로고침 해도 중복 주문 되지 않고 결과 화면만 GET으로 재요청함
  
      3. 특수 리다이렉션 : 결과 대신 캐시를 사용
  
         - 304 Not Modified : 클라이언트의 캐시에 있는 리소스가 만료된 것 같으니 서버에게 다시 리소스를 달라고 요청. 서버는 캐시에 있는 리소스 그대로 써도 된다고 응답. 따라서 클라이언트는 캐시를 재사용(캐시로 리다이렉트)
  
- 4xx : 클라이언트가 뭔가 잘못 요청함(요청 구문, 메시지 등) -> 똑같은 요청을 재시도해도 실패함
  
  - 401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요함
      - 인증 : 본인이 누구인지 확인(로그인)
    - 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함
      - 로그인은 됐는데 접근 권한이 없음
    - 404 Not Found : 요청 리소스를 찾을 수 없음(클라이언트가 요청한 리소스 자체가 없음) / 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때
  
- 5xx : 서버 오류 -> 똑같은 요청을 재시도하면 성공할 수도 있음
  
  - 500 Internal Server Error : 서버 내부 문제로 오류 발생. 애매하면 500 오류로 하면 됨
    - 503 Service Unavailable : 일시적으로 서비스 이용 불가
    - 5xx는 정말 최소한으로! 진짜 서버에 문제가 있을 때만!



## HTTP 헤더

: HTTP 전송에 필요한 모든 부가 정보(메시지 바디를 제외한 모든 것)

<img width="270" alt="HTTP" src="https://user-images.githubusercontent.com/43772750/141645777-b1a61817-944c-403d-a683-e7d3b553d760.PNG">

#### 표현 헤더

: 표현 데이터에 대한 부가 정보

- Content-Type : 표현 데이터의 형식
  - `Content-Type: text/html;charset=UTF-8`
- Content-Encoding : 압축된 데이터를, 인코딩 헤더의 정보로 압축 해제
  - `Content-Encoding: gzip`
- Content-Language : 표현 데이터의 자연 언어
  - `Content-Language: en`
- Contenet-Length : 표현 데이터의 길이(바이트 단위)
  - `Content-Length: 215`

#### HTTP Body

- 메시지 본문(메시지 바디)을 통해 표현 데이터를 전달

#### 표현

: '회원'이라는 리소스를 HTML/JSON...으로 표현한다

#### 협상(Content Negotitation)

: 클라이언트가 선호하는 표현을 요청

- Accept-Language : 클라이언트가 선호하는 자연 언어
  - 클라이언트가 서버에 요청 메시지를 날릴 때 `Accept-Language: ko`를 실어서 보내면, 서버가 이를 참고해서 응답 메시지의 언어를 결정(`Content-Language: ko`)
  - 그런데 클라이언트가 선호하는 언어를, 서버가 지원하지 않는다면?
    - 클라이언트의 요청 메시지에 `Accept-Language: ko-KR, ko;q=0.9, en-US;q=0.8, en;q=0.7`를 실어서 우선순위를 표현
      - 1에 가까울수록 우선순위가 높음
      - q 생락하면 1
    - 서버가 우선순위를 참고해서 응답 메시지의 언어를 결정
- Accept : 클라이언트가 선호하는 미디어 타입(XML, JSON 등등..)
  - 구체적인 것일수록 우선순위가 높음
    - `Accept: text/*, text/plain, text/plain;format=flowed, */*`
      - text/plain;format=flowed가 우선순위가 가장 높음



### 전송 방식

1. 단순 전송
   
- 서버가 응답 메시지를 보낼 때 메시지 바디의 길이를 알아서  `Content-Length`를 지정 -> 요청한 데이터를 한번에 보냄
   
2. 압축 전송

   - 서버가 응답 메시지를 보낼 때 데이터를 압축해서 보냄
   - `Content-Encoding: gzip`

3. 분할 전송

   - ```java
     HTTP/1.1 200 OK
     Content-Type: text/plain
     Transfer-Encoding: chunked
         
     5
     Hello
     5
     World
     0
     \r\n
     ```

   - 5바이트의 Hello를 먼저 보내고, 그후에 5바이트의 World를 보내고... 0을 보내면 끝

   - 헤더에 Content-Length를 포함하지 않음

4. 범위 전송

   - 클라이언트가 데이터를 받다가 중간에 끊김. 그러면 그 이후의 데이터부터 다시 받으면 됨. 이때 범위를 지정해서 서버에게 요청할 수 있음.

   - ```java
     //클라이언트의 요청 메시지
     GET /event
     Range: bytes=1001-2000
         
     //서버의 응답 메시지 헤더
     HTTP/1.1 200 OK
     Content-Type: text/plain
     Content-Range: bytes 1001-2000 / 2000
     ```



### 정보성 헤더

#### 일반 정보

- referer

  - 현재 요청된 페이지 바로 전의 웹 페이지 주소

  - `referer: [웹페이지 주소]`
  - 유입 경로 분석할 때 자주 사용

- User-Agent
  - 클라이언트의 애플리케이션(주로 웹 브라우저) 정보
  - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능

#### 특별한 정보

- Host
  - 요청 메시지에서 필수 헤더!!
  - 하나의 서버가 여러 도메인을 처리하고 있는 경우(여러 애플리케이션을 구동하고 있을 때), 클라이언트의 요청 메시지에 Host 헤더를 추가해서 서버의 어떤 도메인에 해당하는 것인지 알 수 있게 해야 함
  - <img width="418" alt="host" src="https://user-images.githubusercontent.com/43772750/141647502-0256e3f8-d6cf-4c99-9e4a-5184a7765fef.PNG">

- Location
  - 응답 상태 코드가 2xx : 요청에 의해 생성된 리소스의 URI
  - 응답 상태 코드가 3xx : Location 위치로 자동 이동(리다이렉트)
- Allow
  - 응답 상태 코드가 405인 경우, 헤더에 포함해야 함
  - 언급된 HTTP 메소드들만 지원한다고 알려줌
  - `Allow: GET, HEAD, PUT`
  - 자주 구현되어있지 않음

#### 인증

: 클라이언트 인증 정보를 서버에 전달

음... 인증 매커니즘마다 값이 다 달라서 몰라도 될 것 같음

#### 쿠키

: 사용자 로그인 세션 관리, 광고 정보 트래킹(이 웹브라우저 쓰는 사람이 이런 광고를 자주 보는구나)에 사용

- 쿠키를 사용하지 않는 경우

  웹 브라우저가 로그인을 하든 안하든 서버는 얘가 로그인 했는지 모름. 왜냐하면 웹 브라우저가 보내는 요청 메시지에 로그인에 관한 정보가 없기 때문.

  - <img width="414" alt="쿠키 미사용" src="https://user-images.githubusercontent.com/43772750/141648080-d0d72541-b397-46f9-8b39-e7bb8f0032e2.PNG">

  이는 HTTP는 무상태(stateless) 프로토콜이기 때문임. 요청과 응답을 주고받으면 연결이 끊어지기 때문에, 서버는 클라이언트의 이전 요청을 기억하지 못함!

  그렇다면 웹 브라우저의 요청 메시지에 사용자 정보(로그인 정보)를 항상 포함하면 어떨까? 너무 귀찮음!

- 쿠키를 사용하는 경우

  웹 브라우저가 로그인을 해서 POST 메시지를 보내면, 서버가 응답 메시지에 쿠키를 실어 보냄. 웹브라우저 내부에는 쿠키 저장소가 있는데, 쿠키를 받은 웹브라우저는 쿠키 저장소에 쿠키를 저장함.

  - <img width="454" alt="쿠키 사용" src="https://user-images.githubusercontent.com/43772750/141648135-76efee5d-ee69-48fb-bbcf-07ea0785a461.PNG">

  로그인 이후에는 웹 브라우저가 아까 그 서버로 요청을 보낼 때마다 쿠키 저장소를 뒤져서 쿠키 값을 꺼내 요청 헤더에 실어 보냄.(모든 요청에 쿠키 정보를 자동으로 포함함)

  - <img width="466" alt="로그인 이후 쿠키" src="https://user-images.githubusercontent.com/43772750/141648341-cbd271d9-7e1c-40d2-8438-1e1fd78347ad.PNG">

  - 쿠키 정보는 네트워크 트래픽을 추가로 유발하기 때문에 최소한의 정보만 사용해야 함(세션 id, 인증 토큰)
  - 매번 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장해두려면 **웹 스토리지** 사용
  - 보안에 민감한 데이터는 쿠키로 저장x
  - 만료일이 되면 쿠키는 삭제됨
    - 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
    - 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지
  - 도메인 적용
    - 도메인을 명시하면, 명시한 도메인 + 서브 도메인에 쿠키를 생성함
      - `domain=example.org` -> example.org 와 dev.example.org 에 적용
    - 도메인을 생략하면, 현재 도메인에만 쿠키를 생성함
      - example.org 에만 적용
  - 경로 지정
    - 경로를 포함한 하위 경로 페이지만 쿠키 접근
      - `path=/home` -> home, /home/level1 가능
  - 보안
    - Secure : 원래 쿠키는 http, https 둘다 전송 가능한데, Secure를 적용하면 https인 경우에만 전송
    - HttpOnly : 원래 JS에서 쿠키 접근 가능한데, JS에서 접근 불가하도록 함
    - SameSite : 요청 도메인, 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송

---



### 캐시 기본 동작

- 캐시가 없다면
  - 같은 데이터를 사용할 때마다 계속 서버에게 데이터를 요청해서 다운로드 받아야 함
  - 느리고 비효율적
- 캐시가 있다면
  - 웹 브라우저가 처음으로 서버에게 데이터 요청을 하면, 서버가 응답 메시지에 `cache-control: max-age=60`(최대 60초까지 캐시 유효) 이런 헤더를 실어서 보냄. 응답을 받은 웹 브라우저는 브라우저 내에 있는 캐시에 저장. 두 번째 요청시 캐시를 먼저 뒤지고, 있으면 서버에게 요청할 필요가 없음.
  - 캐시가 만료된 후 웹 브라우저가 똑같은 데이터를 다시 필요로 하면? 다시 서버에 요청해서 다 다운받기에는 낭비!
    - 캐시를 뒤지는게 나음. 하지만 유효기간이 지났기 때문에 캐시에 있는 데이터와 서버에 있는 데이터가 일치하는지 알아야 함
    - 이를 알려주는게 서버 응답 메시지의 **검증 헤더** : `Last-Modified: 2020년 11월 10일 10:00:00` (데이터의 최종 수정시간)
    - 웹 브라우저는 서버의 응답 결과를 캐시에 저장하는데, 헤더에 `Last-Modified`가 포함되어 있으면, 헤더에 `if-modified-since: 2020년 11월 10일 10:00:00`을 포함한 요청 메시지를 서버에게 보냄
    - 요청 메시지를 받은 서버는 자신이 가지고 있는 데이터의 최종 수정일과 요청 메시지의 데이터 최종 수정일을 비교. 같으면, 수정이 되지 않은 것. 서버는 응답 메시지 상태코드로 `304 Not Modified`를 보냄. **이때 HTTP Body가 없고 헤더만 존재!** ->네트워크 부하가 감소
    - 응답을 받은 웹 브라우저는 캐시의 `cache-control`값을 갱신하고 캐시에서 데이터 꺼내 사용
    - 만약 최종 수정일이 다르면 서버의 데이터가 수정된 것. 서버는 응답 메시지 상태코드로 `200 OK`를 보내고 Body를 포함한 모든 데이터 전송
    - 단점 : 수정이 A->B->A로 돼서 최종 수정일은 다르지만 데이터는 같은 경우에도 모든 데이터를 전송해야 함, 주석처럼 큰 영향이 없는 변경에서 캐시를 유지하고 싶은데 안됨 -> 해결 : ETag
  - ETag : 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - `Etag: "aaaaaa"`
    - 데이터가 변경되면 이 이름을 바꿈
    - **ETag 값이 같으면 캐시 데이터 사용하고, 다르면 서버에게 다시 받으면 됨!**
    - 요청/응답 메시지의 헤더에 `cache-control`, `ETag`만 추가해도 ETag값을 비교하면 데이터가 변경되었는지 확인 가능
      - 캐시 만료시 웹 브라우저가 요청 메시지의 헤더에 `if-None-Match:"aaaaaa`를 실어 보냄
      - 서버의 데이터의 ETag값과 같으면 응답메시지 상태 코드로 `304 Not Modified`를 보냄(HTTP Body는 없음)
      - 응답을 받은 웹 브라우저는 캐시의 `cache-control`값을 갱신하고 캐시에서 데이터 꺼내 사용



### 캐시 관련 헤더

- Cache-Control
  - `Cache-Control: max-age`
    - 캐시 유효시간(초 단위)
  - `Cache-Control: no-cache`
    - 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용
  - `Cache-Control: no-store`
    - 데이터에 민감한 정보가 있으므로 저장x
- ETag 관련
  - `ETag`
  - `If-None-Match`
- Last-Modified 관련
  - `Last-Modified`
  - `if-modified-since`



### 프록시 캐시

한국에 있는 클라이언트가 미국에 있는 원 서버에 메시지를 보내고 응답 받는데는 시간이 꽤 걸림(너무 멀음). 그래서 한국 어딘가에 프록시 캐시 서버를 두어서, 한국의 클라이언트들은 이 서버와 메시지를 주고받아 빠른 응답을 받을 수 있음.

<img width="470" alt="프록시 캐시" src="https://user-images.githubusercontent.com/43772750/141673648-9a98ab8b-d349-47e2-9814-8a3a0889f4e8.PNG">

- 이때 웹 브라우저에 있는 캐시는 **private 캐시**, 프록시 캐시 서버의 캐시는 **public 캐시**
  - `Cache-Control: public`
    - 응답이 public 캐시에 저장되어도 됨
  - `Cache-Control: private`
    - 응답이 해당 사용자만을 위한 것이므로 private 캐시에만 저장(디폴트)



### 캐시 무효화

캐시를 적용하지 않아도 웹 브라우저들이 지맘대로 적용하기도 함. 확실히 캐시를 무효화 하기 위해서는

`Cache-Control: no-cache, no-store, must-revalidate`

- must-revalidate : 캐시 만료후 최초 조회시 origin 서버에 검증해야 함

`Pragma: no-cache`

- Pragma는 HTTP 1.0 하위 호환이지만 가끔 쓰는 곳도 있으므로 넣으면 효과는 확실

